{
    "ingress-path": {
        "name": "Payload length statistics",
        "code": "#include <linux/bpf.h>\r\n#include <linux/if_vlan.h>\r\n#include <linux/if_ether.h>      // struct ethhdr\r\n#include <linux/pkt_cls.h>\r\n#include <linux/if_ether.h>\r\n#include <linux/ip.h>\r\n#include <linux/ipv6.h>\r\n#include <linux/icmp.h>\r\n#include <linux/tcp.h>\r\n#include <linux/udp.h>\r\n#include <linux/ip.h>\r\n\r\n#define BINBASE 4\r\n#define NBINS 0x1<<BINBASE\r\n\r\n\r\n/* Exit return codes */\r\n#define EXIT_OK        0 /* == EXIT_SUCCESS (stdlib.h) man exit(3) */\r\n#define EXIT_FAIL       1 /* == EXIT_FAILURE (stdlib.h) man exit(3) */\r\n#define EXIT_FAIL_OPTION    2\r\n#define EXIT_FAIL_XDP      30\r\n#define EXIT_FAIL_BPF      40\r\n\r\n\r\n\r\n/* TODO: Improve performance by using multiple per-cpu hash maps.\r\n */\r\nBPF_ARRAY(nw_stats_map, __u32, NBINS);\r\n\r\n\r\n/* Header cursor to keep track of current parsing position */\r\nstruct hdr_cursor {\r\n        void *pos;\r\n};\r\n\r\n/* TCP options */\r\n#define TCP_OPT_END   0\r\n#define TCP_OPT_NONE   1\r\n#define TCP_OPT_MSS   2\r\n#define TCP_OPT_WNDWS   3\r\n#define TCP_OPT_SACKP   4\r\n#define TCP_OPT_SACK   5\r\n#define TCP_OPT_TS   8\r\n\r\nstruct tcp_opt_none {\r\n   __u8 type;\r\n};\r\n\r\nstruct tcp_opt_mss {\r\n   __u8 type;\r\n   __u8 len;\r\n   __u16 data;\r\n};\r\n\r\nstruct tcp_opt_wndw_scale {\r\n   __u8 type;\r\n   __u8 len;\r\n   __u8 data;\r\n};\r\n\r\nstruct tcp_opt_sackp {\r\n   __u8 type;\r\n   __u8 len;\r\n};\r\n\r\n/* Bypassing the verifier check is not simple with variable data,\r\n * but for now I don't need to parse sack data.\r\n */\r\nstruct tcp_opt_sack {\r\n   __u8 type;\r\n   __u8 len;\r\n//   __u32 data[8];\r\n};\r\n\r\nstruct tcp_opt_ts {\r\n   __u8 type;\r\n   __u8 len;\r\n   __u32 data[2];\r\n};\r\n\r\nstruct tcpopt {\r\n   struct tcp_opt_mss *op_mss;\r\n   struct tcp_opt_wndw_scale *op_wndw_scale;\r\n   struct tcp_opt_sackp *op_sackp;\r\n   struct tcp_opt_sack *op_sack;\r\n   struct tcp_opt_ts *op_ts;\r\n};\r\n\r\nstruct optvalues {\r\n   __u16 mss;\r\n   __u8 wndw_scale;\r\n   __u32 timestamp1;\r\n   __u32 timestamp2;\r\n};\r\n\r\nstatic __always_inline int tcpopt_type(void * tcph, unsigned int offset, void *data_end)\r\n{\r\n   struct tcp_opt_none *opn;\r\n\r\n   opn = (struct tcp_opt_none *)(tcph+offset);\r\n\r\n   if ( (void *)(opn+1) > data_end )\r\n      return -1;\r\n   else\r\n      return opn->type;\r\n   \r\n}\r\n\r\nstatic __always_inline int proto_is_vlan(__u16 h_proto)\r\n{\r\n        return !!(h_proto == bpf_htons(ETH_P_8021Q) ||\r\n                  h_proto == bpf_htons(ETH_P_8021AD));\r\n}\r\n\r\n/*\r\n      * Struct icmphdr_common represents the common part of the icmphdr and icmp6hdr\r\n      *  * structures.\r\n      *   */\r\nstruct icmphdr_common {\r\n        __u8   type;\r\n   __u8    code;\r\n   __sum16 cksum;\r\n};\r\n\r\n\r\n/* Parse the Ethernet header and return protocol.\r\n * Ignore VLANs.\r\n *\r\n * Protocol is returned in network byte order.\r\n */\r\nstatic __always_inline int parse_ethhdr(struct hdr_cursor *nh,\r\n                                        void *data_end,\r\n                                        struct ethhdr **ethhdr)\r\n{\r\n       struct ethhdr *eth = nh->pos;\r\n        int hdrsize = sizeof(*eth);\r\n        struct vlan_hdr *vlh;\r\n        __u16 h_proto;\r\n        int i;\r\n\r\n        /* Byte-count bounds check; check if current pointer + size of header\r\n         * is after data_end.\r\n         */\r\n        if (nh->pos + hdrsize > data_end)\r\n                return -1;\r\n\r\n        nh->pos += hdrsize;\r\n        *ethhdr = eth;\r\n        vlh = nh->pos;\r\n        h_proto = eth->h_proto;\r\n\r\n        /* Use loop unrolling to avoid the verifier restriction on loops;\r\n         * support up to VLAN_MAX_DEPTH layers of VLAN encapsulation.\r\n         */\r\n        #pragma unroll\r\n        for (i = 0; i < VLAN_MAX_DEPTH; i++) {\r\n                if (!proto_is_vlan(h_proto))\r\n                        break;\r\n\r\n                if ( (void *)(vlh + 1) > data_end)\r\n                        break;\r\n\r\n                h_proto = vlh->h_vlan_encapsulated_proto;\r\n                vlh++;\r\n        }\r\n\r\n        nh->pos = vlh;\r\n        return bpf_ntohs(h_proto); /* host-byte-order */\r\n\r\n\r\n}\r\n\r\nstatic __always_inline int parse_iphdr(struct hdr_cursor *nh,\r\n                   void *data_end,\r\n                   struct iphdr **iphdr)\r\n{\r\n   struct iphdr *iph = nh->pos;\r\n   int hdrsize;\r\n\r\n   if ( (void *)(iph + 1) > data_end)\r\n      return -1;\r\n\r\n   hdrsize = iph->ihl * 4;\r\n   // Sanity check packet field is valid/\r\n   if(hdrsize < sizeof(iph))\r\n      return -1;\r\n\r\n   // Variable-length IPv4 header, need to use byte-based arithmetic \r\n   if (nh->pos + hdrsize > data_end)\r\n      return -1;\r\n\r\n   nh->pos += hdrsize;\r\n   *iphdr = iph;\r\n\r\n   return iph->protocol;\r\n}\r\n\r\nstatic __always_inline int parse_ip6hdr(struct hdr_cursor *nh,\r\n               void *data_end,\r\n               struct ipv6hdr **ip6hdr)\r\n{\r\n   struct ipv6hdr *ip6h = nh->pos;\r\n\r\n   /* Pointer-arithmetic bounds check; pointer +1 points to after end of\r\n    * thing being pointed to. We will be using this style in the remainder\r\n    * of the tutorial.\r\n    */\r\n    if ( (void *)(ip6h + 1) > data_end)\r\n      return -1;\r\n\r\n   nh->pos = ip6h + 1;\r\n   *ip6hdr = ip6h;\r\n\r\n   return ip6h->nexthdr;\r\n}\r\n         \r\n\r\n/*\r\n * parse_udphdr: parse the udp header and return the length of the udp payload\r\n */\r\nstatic __always_inline int parse_udphdr(struct hdr_cursor *nh,\r\n               void *data_end,\r\n               struct udphdr **udphdr)\r\n{\r\n   int len;\r\n   struct udphdr *h = nh->pos;\r\n\r\n   if ((void *)(h + 1) > data_end)\r\n      return -1;\r\n\r\n   nh->pos  = h + 1;\r\n   *udphdr = h;\r\n\r\n   len = bpf_ntohs(h->len) - sizeof(struct udphdr);\r\n   if (len < 0)\r\n      return -1;\r\n\r\n   return len;\r\n}\r\n\r\nstatic __always_inline int parse_tcpopt(struct tcphdr *tcph,\r\n               void *data_end,\r\n               struct optvalues *value)\r\n{\r\n   unsigned short op_tot_len = 0;\r\n   unsigned short last_op = 0;\r\n   struct tcp_opt_mss *mss = 0;\r\n   struct tcp_opt_wndw_scale *wndw_scale = 0;\r\n   struct tcp_opt_sackp *sackp = 0;\r\n   struct tcp_opt_sack *sack = 0;\r\n   struct tcp_opt_ts *ts = 0;\r\n   unsigned int offset = 20;\r\n   __u8 type;\r\n\r\n   op_tot_len = (tcph->doff - 5)*4;\r\n\r\n   if( op_tot_len < 0 )\r\n      return -1;\r\n   \r\n   if( (void *)(tcph+1)+op_tot_len > data_end )\r\n      return -1;\r\n\r\n   /* 10 loops is arbitrary, hoping this could cover most use-cases.\r\n    * A fixed boundary is required by the internal verifier.\r\n    */\r\n   for(unsigned int i=0; i<5; i++)\r\n   {\r\n      type = tcpopt_type((void *) tcph, offset,data_end);\r\n   \r\n      switch ( type ) {\r\n         case TCP_OPT_END:\r\n            last_op = 1;\r\n         case TCP_OPT_NONE:\r\n            offset++;\r\n            op_tot_len--;\r\n            break;\r\n         case TCP_OPT_MSS:\r\n            mss = (struct tcp_opt_mss *)((void *)tcph+offset);\r\n            if( (void *)(mss+1) > data_end )\r\n               return -1;\r\n            offset+=mss->len;\r\n            op_tot_len-=mss->len;\r\n            value->mss = bpf_ntohs(mss->data);\r\n            break;\r\n         case TCP_OPT_WNDWS:\r\n            wndw_scale = (struct tcp_opt_wndw_scale *)((void *)tcph+offset);\r\n            if( (void *)(wndw_scale+1) > data_end )\r\n               return -1;\r\n            offset+=wndw_scale->len;\r\n            op_tot_len-=wndw_scale->len;\r\n            value->wndw_scale = wndw_scale->data;\r\n            break;\r\n         case TCP_OPT_SACKP:\r\n            sackp = (struct tcp_opt_sackp *)((void *)tcph+offset);\r\n            if( (void *)(sackp+1) > data_end)\r\n               return -1;\r\n            offset+=sackp->len;\r\n            op_tot_len-=sackp->len;\r\n            // No data read for this option\r\n            break;\r\n         case TCP_OPT_SACK:\r\n            sack = (struct tcp_opt_sack *)((void *)tcph+offset);\r\n            if( (void *)(sack+1) > data_end)\r\n               return -1;\r\n            offset+=sack->len;\r\n            op_tot_len-=sack->len;\r\n            // No data read for this option\r\n            break;\r\n         case TCP_OPT_TS:\r\n            ts = (struct tcp_opt_ts *)((void *)tcph+offset);\r\n            if( (void *)(ts+1) > data_end)\r\n               return -1;\r\n            offset+=ts->len;\r\n            op_tot_len-=ts->len;\r\n            value->timestamp1=bpf_ntohl(ts->data[0]);\r\n            value->timestamp2=bpf_ntohl(ts->data[1]);\r\n            break;\r\n         default:\r\n            last_op = 1;\r\n            break;\r\n\r\n      }\r\n\r\n      if ( last_op || op_tot_len <= 0)\r\n         break;\r\n   }\r\n\r\n   return op_tot_len;\r\n}\r\n\r\n/*\r\n * parse_tcphdr: parse and return the length of the tcp header\r\n */\r\nstatic __always_inline int parse_tcphdr(struct hdr_cursor *nh,\r\n               void *data_end,\r\n               struct tcphdr **tcphdr)\r\n{\r\n   int len;\r\n   struct tcphdr *h = nh->pos;\r\n\r\n   if ((void *)(h + 1) > data_end)\r\n      return -1;\r\n\r\n   len = h->doff * 4;\r\n   // Sanity check packet field is valid \r\n   if(len < sizeof(h))\r\n      return -1;\r\n\r\n   // Variable-length TCP header, need to use byte-based arithmetic \r\n   if (nh->pos + len > data_end)\r\n      return -1;\r\n\r\n   nh->pos += len;\r\n   *tcphdr = h;\r\n\r\n   return data_end - nh->pos;\r\n}\r\n\r\n\r\n\r\nstatic __always_inline  int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md)\r\n{\r\n   /* Preliminary step: cast to void*.\r\n    * (Not clear why data/data_end are stored as long)\r\n    */\r\n   void *data_end = (void *)(long)ctx->data_end;\r\n   void *data     = (void *)(long)ctx->data;\r\n   __u32 ipfield = 0;\r\n   __u32 len = 0;\r\n   __u32 init_value = 1;\r\n   unsigned int vers = 0;\r\n   int op_len=0;\r\n   int eth_proto, ip_proto = 0;\r\n   /* int eth_proto, ip_proto, icmp_type = 0; */\r\n/*   struct flowid flow = { 0 }; */\r\n   struct hdr_cursor nh;\r\n   struct ethhdr *eth;\r\n   struct ipv6hdr* iph6;\r\n   struct iphdr *iph4;\r\n   struct tcphdr *tcphdr = 0;\r\n   struct udphdr *udphdr = 0;\r\n   struct optvalues tcpopts = { 0 };\r\n   \r\n   /* Parse Ethernet header and verify protocol number. */\r\n   nh.pos = data;\r\n   len = data_end - data;\r\n   eth = (struct ethhdr *)data;\r\n   eth_proto = parse_ethhdr(&nh, data_end, &eth);\r\n   if ( eth_proto < 0 ) {\r\n      return TC_ACT_OK; /* TODO: XDP_ABORT? */\r\n   }\r\n\r\n   /* Parse IP header and verify protocol number. */\r\n   switch (eth_proto) {\r\n      case ETH_P_IP:\r\n         ip_proto = parse_iphdr(&nh, data_end, &iph4);\r\n         vers = 4;\r\n         break;\r\n      case ETH_P_IPV6:\r\n         ip_proto = parse_ip6hdr(&nh, data_end, &iph6);\r\n         vers = 6;\r\n         break;\r\n      default:\r\n         return TC_ACT_OK;\r\n   }\r\n\r\n   if( ip_proto < 0 ) {\r\n      return TC_ACT_OK;\r\n   }   \r\n\r\n   switch (ip_proto) {\r\n   /*   case IPPROTO_ICMP:\r\n      case IPPROTO_ICMPV6:\r\n         if( process_icmp_header(&nh, data_end, &icmphdrc, &key) < 0 )\r\n            return TC_ACT_OK;\r\n         break;*/\r\n      case IPPROTO_TCP:\r\n         if( parse_tcphdr(&nh, data_end, &tcphdr) < 0 ) {\r\n            return TC_ACT_OK;\r\n         }\r\n         else\r\n            op_len = parse_tcpopt(tcphdr, data_end, &tcpopts);\r\n         break;\r\n      case IPPROTO_UDP:\r\n         if( parse_udphdr(&nh, data_end, &udphdr) < 0 )\r\n            return TC_ACT_OK;\r\n         break;\r\n      default:\r\n         /* TODO: cound how many packets/bytes are seen from\r\n          * unmanaged protocols, so we can understand the impact\r\n          * of such traffic. \r\n          * Hints: a common line with IPPROTO_MAX may be used.\r\n          */\r\n         return TC_ACT_OK;\r\n   }\r\n\r\n   /* Check statistics\r\n    */\r\n   if ( vers == 6 ) {\r\n      if( (void*) iph6 + sizeof(struct ipv6hdr) < data_end) {\r\n            ipfield = bpf_ntohs(iph6->payload_len);\r\n      }\r\n   }\r\n   else {\r\n      if ( (void*) iph4 + sizeof(struct iphdr) < data_end) {\r\n         \r\n      }\r\n   }\r\n\r\n   /* Collect the required statistics. */\r\n   __u32 key = ipfield >> (8-BINBASE);\r\n   __u32 *counter = \r\n      nw_stats_map.lookup(&key);\r\n   if(!counter)\r\n      nw_stats_map.update(&key, &init_value);\r\n   else\r\n      __sync_fetch_and_add(counter, 1);\r\n\r\n   \r\n   return TC_ACT_OK;\r\n}\r\n\r\n",
        "metric-configs": [
            {
                "name": "Payload length occurrences",
                "map-name": "nw_stats_map",
					 "open-metrics-metadata": {
						 "help": "This metrics measures the distribution of payload length values in IPv6 packets.",
						 "type": "histogram",
						 "labels": [
						 {
							 "name": "IP_VERS",
							 "value": "IPv6"
						 },
						 {
							 "name": "FIELD",
							 "value": "PAYLOAD_LEN"
						 }
						 ]
					 }
            }
        ]
    },
    "egress-path": {}
}
